@import: ../../shinchoku-tairiku.satyh/shinchoku-tairiku

module Youxkei : sig
    direct +youxkei : [] block-cmd
end = struct
    let-inline \dfn word = {\emph{#word;}}

    let-inline \ref label = {\ref(`youxkei:` ^ label);}
    let-inline \figref label = {図\ref(`figure:` ^ label);}
    let-inline \coderef label = {コード\ref(`code:` ^ label);}

    let-block +figure label size caption = '<
        +figure?:(`youxkei:figure:` ^ label)?:(size)(`youxkei/` ^ label ^ `.pdf`){#caption;}
    >

    let-block +code label code caption = '<
        +code?:(`youxkei:code:` ^ label)(code){#caption;}
    >

    let bib-items = [
        (`ogr`, BibArticle (|
            title = {Optical Graph Recognition};
            author = {Auer, Christopher and Bachmaier, Christian and Brandenburg, Franz J. and Gleißner, Andreas and Reislhuber, Josef};
            journal = {Graph Drawing};
            year = 2013;
        |))
    ]

    let-block +youxkei = '<
        +chapter?*?:(bib-items){QRコードみたいな魔法陣を作る}{水35L 炭素20㎏ アンモニア4L 石灰1.5㎏ リン800g 塩分250g 硝石100g 硫黄80g フッ素7.5g 鉄5g ケイ素3g その他少量の15の元素... - エドワード・エルリック}<
            +section{はじめに}<
                +p{
                    こんにちは。\@youxkeiです。
                    今回は、QRコードっぽい魔法陣を作る話をしていきます。
                }
                +p{
                    ファンタジー作品では、よく魔法が登場します。
                    魔法が存在する作品の中でも、魔法陣を起点として魔法が発動する描写がされている作品がいくつかあります。
                }
                +p{
                    魔法陣から魔法が発動する描写、かっこいいですよね！かっこいいなぁと思いながら作品を見ていて、あるとき、ふとこう思いました。
                }
                +p{
                    「ほとんどの場合、魔法陣とそこから発動する魔法は一対一に対応しているんだから、魔法陣の形は何らかの意味をもっているはず」
                }
                +p{
                    ファンタジー作品の中の魔法陣と同じように、現実世界の魔法陣にも意味をもたせることができると、とても面白そうです。
                    意味を持つ魔法陣は、言い換えるなら情報を持つ魔法陣、ということになりそうです。
                }
                +p{
                    ところで、情報を持つ二次元図形と聞くと、思い浮かぶものがありますよね。そうです、バーコードやQRコードです\footnote{厳密に言えば「文字列」も情報を持つ二次元図形ではありますね・・・}。
                }
                +p{
                    つまりこの章では、QRコードのように情報を持つことができて、さらにその情報を機械が読み取ることができる魔法陣はどんなものであるかを考え、実際に作っていきます。
                }
                +p{
                    QRコードをリスペクトして、この章で作るQRコードっぽい魔法陣の名前は\dfn{MCコード}としました。MCはMagic Circleの頭文字です。
                }
            >

            +section{情報をもつ魔法陣}<
                +p{
                    魔法陣というと、\figref(`magic_circle`);のような典型的なものを想像します。
                    この典型的な魔法陣を見ていると、情報を埋め込んだり、埋め込んだ情報を機械で読み取るのは難しそうに感じます。
                }
                +p{
                    ところで、この典型的な魔法陣を見ていると、数学の授業でなにか似たようなものを見たことがあるような気がします。
                    そうです。グラフです。
                }
                +figure(`magic_circle`)(6cm){典型的な魔法陣}
                +p{
                    当然、ここでのグラフは\figref(`not_graph`);のグラフではなく、\figref(`graph`);のグラフです。
                }
                +p{
                    グラフであれば、情報を埋め込むことができますし、機械で読み取りやすそうです。
                    グラフに情報を埋め込み、そのグラフを魔法陣っぽく表示することで、情報を機械が読み取ることができる魔法陣を作ることができそうです。
                }
                +row{
                    | \minipage(0.5)<+figure(`not_graph`)(7cm){こちらの方のグラフではない}>
                    | \minipage(0.5)<+figure(`graph`)(6cm){こちらの方のグラフ}>
                |}
            >

            +section{MCコードの構成}<
                +p{
                    MCコードの構造として、無向多重グラフを採用しました。
                    多重グラフでは、頂点と頂点の間に複数の辺を張ることができます。
                    MCコードでは、MCコードの構造を表す辺として主に2重の辺を、MCコードに埋め込まれたデータを表す辺として主に1重の辺を使うことにします。
                }
                +p{
                    MCコードは次のような再帰的な構造となっています。
                }
                +subsection{基本形}<
                    +p{
                        MCコードの基本形は\figref(`mccode_base`);のような形です。
                    }
                    +figure(`mccode_base`)(3cm){MCコードの基本形}
                    +p{
                        ここで、2重の辺で繋がれた閉路を\dfn{フレーム}と呼ぶことにします。
                        基本形にはただ1つのフレームが存在します。
                    }
                    +p{
                        基本形にはいくつかの頂点があり、フレームに属する頂点とフレームに属さない頂点があります。
                        フレームに属さない頂点のことを、その配置される場所から\dfn{中心頂点}と呼ぶことにします。
                    }
                    +p{
                        中心頂点から伸びている2重の辺を\dfn{橋辺}と呼び、中心頂点から伸びている1重の辺を\dfn{方向辺}と呼ぶことにします。
                        さらに、橋辺に繋がっているフレーム上の頂点を、フレームの\dfn{起頂点}と呼び、
                        方向辺に繋がっているフレーム上の頂点を、フレームの\dfn{方向頂点}と呼ぶことにします。
                        フレーム上の頂点は、起頂点から方向頂点に向かう方向に番号を振ることができます。
                        起頂点と方向頂点は、MCコードを機械で読み取る際、グラフの隣接リストから頂点の番号を得るために必要になります。
                    }
                    +p{
                        ここで、MCコードの\dfn{密度}を導入します。基本形の密度は、フレーム上の頂点の数です。
                        \figref(`mccode_base`);の例では、密度は9となっています。
                        フレーム上には起頂点と方向頂点が必要なので、密度は2以上である必要があります。
                    }
                    +p{
                        更に\dfn{最外フレーム}も導入します。
                        基本形の最外フレームは、基本形にただ1つ存在するフレームです。
                    }
                    +p{
                        密度によらず、中心頂点の次数は3になることが分かります。
                    }
                >
                +subsection{フレーム追加}<
                    +p{
                        いま、\figref(`mccode_m`);のようにMCコード${M}があるとします。
                        このMCコード${M}の外側にフレームを追加したMCコード${M'}は、\figref(`mccode_m_prime`);のようになります。
                    }
                    +p{
                        追加するフレームの頂点数は、${M}の頂点数に密度を足した数になります。
                        ${M}の最外フレームの頂点数は27、${M}の密度は9なので\footnote{図からは${M}の密度が9であることは分かりませんが、ここでは9であるとします}、追加したフレームの頂点数は36となっています。
                    }
                    +p{
                        ${M}の最外フレームから追加したフレームにいつくかの辺が張られています。
                        それらの辺のうち1つだけ2重の辺があり、この辺のことも基本形と同じく橋辺と呼ぶことにします。
                        さらに、橋辺に繋がっている${M}の最外フレーム上の頂点から伸びている1重の辺のことも基本形と同じく方向辺と呼ぶことにします。
                    }
                    +p{
                        橋辺に繋がっている追加したフレーム上の頂点が追加したフレームの起頂点になり、
                        方向辺に繋がっている追加したフレーム上の頂点が追加したフレームの方向頂点になります。
                        追加したフレームの起頂点と方向頂点を明確にするため、必ず橋辺と方向辺が存在する必要があります。
                    }
                    +row{
                        | \minipage(0.5)<+figure(`mccode_m`)(6cm){${M}}>
                        | \minipage(0.5)<+figure(`mccode_m_prime`)(6cm){${M'}}>
                    |}
                    +p{
                        ${M}の最外フレームから追加したフレーム張られている辺のうち、橋辺と方向辺でない辺は情報埋め込みのため辺であるため、ここでは\dfn{データ辺}と呼ぶことにします。
                        情報の埋め込み方法は単純で、データ辺が張られていれば1、データ辺が張られていれば0を表します。
                    }
                    +p{
                        ${M'}の密度は${M}の密度となり、${M'}の最外フレームは追加したフレームとなります。
                    }
                >
            >

            +section{MCコードの性質}<
                +p{
                    MCコードを機械で読み取る上で重要となるMCコードの性質があります。それは、「全てのMCコードには次数が3となる頂点がただ1つ存在する」という性質です。
                    その頂点とは、基本形に出てきた中心頂点です。
                    この性質は比較的簡単に証明できるため、ここに証明を載せます。
                }
                +theorem{
                    全てのMCコード${M}には次数が3となる頂点がただ1つ存在する。
                }
                +proof<
                    +p{
                        ${M}の構造に関する帰納法で証明する。
                    }
                    +p{
                        ${M}が基本形である場合、${M}の中心頂点の次数が3であり、中心頂点以外のフレーム上の頂点の次数は全て4である。
                        したがって、中心頂点が求める頂点である。
                    }
                    +p{
                        ${M}がフレーム追加、つまり\figref(`mccode_add_frame`);のような形をしている場合、${M}の最外フレームの内側にMCコード${M'}を含む形となる。
                        帰納法の仮定より、${M'}には次数が3となる唯一の頂点が存在するので、その頂点を${V}とする。
                        ${M}の最外フレーム上の頂点は全て次数が4である。
                        したがって、${M}に唯一存在する次数が3となる頂点は${V}であり、この${V}が求める頂点である。
                    }
                    +figure(`mccode_add_frame`)(6cm){${M}}
                >
                +p{
                    MCコードにはただ1つの中心頂点が存在するので、
                    その中心頂点から橋辺と方向辺をたどって全てのフレーム上の頂点に番号を振り、
                    頂点間に張られていたりいなかったりするデータ辺を見ることで、
                    MCコードに埋め込まれた情報を機械で読み取ることができます。
                }
            >

            +section{MC Code Generator}<
                +figure(`mccode_hello`)(6cm){\code(`Hello, world!`);という文字列を埋め込んだMCコード}
                +p{
                    MCコードの構成が決まったので、MC Code Generator\footnote{\url(`https://youxkei.github.io/mccode_generator/`);}を作ってみました。
                    \figref(`mccode_hello`);はMC Code Generatorで作成した\code(`Hello, world!`);という文字列を埋め込んだMCコードです。
                }
                +p{
                    \figref(`mccode_hello`);のMCコードにはデータ以外に、バージョン番号とマスクパターン番号を含めています。
                }
            >

            +section{MCコードを読み取る}<
                +p{
                    ここから、MCコードを機械で読み取るにはどうしたら良いかを考えていきます。
                    MCコードの構成を考える際、機械での読み取りやすさを考慮して、MCコードを無向多重グラフで構成するようにしたと書きました。
                    なので、次のような流れで情報を読み取ることができそうです。
                }
                +enumerate{
                    * MCコードの画像からグラフを認識し、その隣接リストを計算する
                    * 隣接リストから、MCコードに埋め込まれた情報を抽出する
                }
                +p{
                    画像から無向グラフを認識するタスクに関して、先行研究があります。Auerらによる『Optical Graph Recognition』\cite(`ogr`);です。
                    ほぼ論文のとおりに実装することで、MCコードの画像からグラフの隣接リストを計算することができました。
                    ここでは、Optical Graph Recognitionの実装を簡単に解説していきます。
                }
            >

            +section{Optical Graph Recognition}<
                +p{
                    Optical Graph Recognitionでは、次のような流れでグラフ画像を認識します。
                }
                +enumerate{
                    * 画像を二値化する
                    * 二値画像から頂点部分画像の生成する
                    * 二値画像を細線化する
                    * 細線化した画像について、ピクセルを分類する
                    * ピクセルを分類した細線化画像から隣接リストを計算する
                }
                +p{
                    それぞれのステップについて説明していきます。
                    説明のための入力画像として、MCコードの基本形である\figref(`mccode_base`);を使います。
                }
                +subsection{画像の二値化}<
                    +p{
                        画像の二値化には色々は方法がありますが、ここでは\dfn{大津の二値化}を使います。
                        実際に\figref(`mccode_base`);を二値化した画像が\figref(`mccode_binary`);です。
                    }
                    +figure(`mccode_binary`)(6cm){二値化した画像}
                    +p{
                        \figref(`mccode_binary`);は入力となった\figref(`mccode_base`);と比べて白黒が反転していることに気づいたと思います。
                        以降のステップを実装する上で白黒を反転させると都合が良いので、ここで反転の処理を追加しています。
                        なので、反転処理自体は本質的なものではないです。
                    }
                >
                +subsection{頂点部分画像の生成}<
                    +p{
                        二値化した画像に対して\dfn{収縮}と呼ばれる処理をすることで、白の部分を減らし、その結果\figref(`mccode_eroded`);のように辺部分を消し頂点部分のみを残した画像を生成することができます。
                        収縮の際は何ピクセル収縮させるかを決める必要があります。
                        ここでは「最も黒ピクセルから遠い白ピクセルの、黒ピクセルまでの距離」を計算し、その距離の半分を収縮させるピクセル数としています。
                    }
                    +p{
                        収縮させた画像に対して\dfn{膨張}と呼ばれる処理をすることで、\figref(`mccode_dilated`);のような頂点部分を表す画像を得ることができます。
                        この時の膨張させるピクセル数は収縮させたピクセル数と同じにします。
                    }
                    +row{
                        | \minipage(0.5)<+figure(`mccode_eroded`)(6cm){二値画像を収縮させた画像}>
                        | \minipage(0.5)<+figure(`mccode_dilated`)(6cm){収縮した画像を膨張させた画像}>
                    |}
                    +p{
                        実は、\figref(`mccode_dilated`);を頂点部分画像として使うと、後のステップで不都合があります。
                        そこで、非常に場当たり的な解決策ではありますが、
                        \figref(`mccode_dilated`);をより膨張させた\figref(`mccode_vertices`);のような画像を頂点部分画像として使用することにします。
                    }
                    +figure(`mccode_vertices`)(6cm){頂点部分画像}
                >
                +subsection{二値画像の細線化}<
                    +p{
                        頂点部分画像はひとまず横に置いておきまして、二値化した画像を\dfn{細線化}します。
                        細線化は、二値画像を幅1ピクセルの線画像に変換する処理です。
                    }
                    +p{
                        ここでは、4隣接で細線化を行います。
                        4隣接では、あるピクセルの上下左右の4つのピクセルがそのピクセルに隣接するピクセルであるとみなして細線化します。
                        今回は使いませんが、4隣接以外に8隣接での細線化もあります。
                        8隣接では、あるピクセルの上下左右だけではなく斜めも含めた8つのピクセルがそのピクセルに隣接するピクセルであるとして細線化します。
                    }
                    +p{
                        細線化を行うアルゴリズムは色々とあります。
                        ここでは、Hilditchアルゴリズムを使うことにします。
                        実際にHilditchアルゴリズムを使って細線化を行うと、\figref(`mccode_skeleton`);のような画像を得ることができます。
                    }
                    +figure(`mccode_skeleton`)(6cm){細線化した画像}
                >
                +subsection{ピクセルの分類}<
                    +p{
                        頂点部分画像を使って、細線化した画像の白ピクセルの種類を以下の4つに分類します。
                    }
                    +enumerate{
                        * 頂点ピクセル
                        * ポートピクセル
                        * 交点ピクセル
                        * 辺ピクセル
                    }
                    +p{
                        頂点ピクセルは、名前の通り頂点部分のピクセルです。
                        ポートピクセルは、頂点ピクセルに隣接するピクセルです。
                        交点ピクセルは3つ以上の白ピクセルに隣接しているピクセルで、辺が交差しているピクセルを表します。
                        頂点ピクセルでなく、ポートピクセルでなく、交点ピクセルでない白ピクセルは辺ピクセルとなります。
                    }
                    +p{
                        実際に細線化した画像の白ピクセルの分類を行うと、\figref(`mccode_classified_skeleton`);のような画像となります。
                        \figref(`mccode_classified_skeleton`);では、頂点ピクセルが白、辺ピクセルがグレーで表されています。
                    }
                    +figure(`mccode_classified_skeleton`)(6cm){ピクセルを分類した画像}
                >
                +subsection{隣接リストの計算}<
                    +p{
                        分類した細線化画像が得られたら、あとは隣接リストを計算するだけです。
                        まず、同じ頂点に属するポートピクセルで同値類を作成します。
                        同値類の作成にはUnion Find木を使いました。
                        あとは、ポートピクセルから辺ピクセルをたどって\footnote{この辺ピクセルをたどる処理を書いた際、非常に久しぶりに深さ優先探索を書いたので、感慨深い気持ちになりました。}、
                        ポートピクセル同士の繋がり方を調べることで、隣接リストを計算することができます。
                    }
                >
            >

            +section{隣接リストから情報を読み取る}<
                +p{
                    MCコードの画像から隣接リストが計算できたら、後はMCコードに埋め込まれた情報を読み取るだけです。
                    まず、中心頂点を探します。
                    中心頂点は、全ての頂点の中で唯一次数が3なので、すぐに見つかります。
                    中心頂点から橋辺と方向辺をたどって全ての頂点に番号を振ります。
                    それぞれの頂点と頂点の間のデータ辺の張られ方から、MCコードに埋め込まれたデータを読み取ることができます。
                }
            >

            +section{mccode_scanner}<
                +p{MCコードの画像を受け取り、埋め込まれたデータを読み取るプログラムである、mccode_scanner\footnote{\url(`https://github.com/youxkei/mccode_scanner`);}を作りました。}
                +figure(`mccode_wagahai`)(6cm){猫であるMCコード}
                +p{例として\figref(`mccode_wagahai`);をmccode_scannerで読み取ってみると、\coderef(`wagahai`);のようになります。}
                +code(`wagahai`)(```
                    $ cargo -V
                    cargo 1.45.1 (f242df6ed 2020-07-22)

                    $ rustc -V
                    rustc 1.45.2 (d3fb005a3 2020-07-31)

                    $ git clone https://github.com/youxkei/mccode_scanner.git

                    $ cd mccode_scanner

                    $ cargo build --release

                    $ curl -LO https://git.io/mccode_wagahai.png

                    $ target/release/mccode_scanner mccode_wagahai.png
                    吾輩は猫である。
                ```){\figref(`mccode_wagahai`);をmccode_scannerで読み取る}
            >

            +section{今後の課題}<
                +p{
                    今後の課題として、交点ピクセルの適切な処理が挙げられます。
                    Optical Graph Recognitionの説明の際、交点ピクセルの処理に触れていなかったことにお気づきでしょうか。
                    実は、今回の実装では頂点部分を実際の頂点よりも膨張させることで、交点ピクセルが発生しないようにしています。
                    これが、\figref(`mccode_dilated`);をより膨張させた\figref(`mccode_vertices`);を頂点部分画像として使う理由です。
                    この実装は非常に場当たり的で、頂点同士が近づくとすぐに破綻します。
                    より膨張させた画像を頂点部分画像として使うのをやめて、
                    交点ピクセルを適切に処理するようにすることで、受理できるMCコードの範囲が広がります。
                }
                +p{
                    今回、mccode_scannerはRustで実装しました。
                    これは、ソースコードをWebAssemblyにコンパイルして、スマートフォン上のブラウザでMCコードのスキャンを行いたかったためです。
                    QRコードのように、スマートフォン上でカメラに映るMCコードのスキャンを行いたかったのですが、時間が足りずに実装はRustで書いたスキャン部分のみとなってしまいました。
                    これも今後の課題となります。
                }
            >

            +section{あとがき}<
                +p{
                    前々から、どうせ魔法陣を生成するなら情報を埋め込んだ魔法陣を生成したい！と思っていて、この進捗大陸の締切駆動開発でなんとか実装することができました。
                    ただ、MCコードは想像していたよりも魔法陣っぽさがないような気がしています。
                    この辺りは難しいですね・・・
                }
                +p{
                    今回も\SATySFi;での執筆となったのですが、かなり執筆体験が良かったです。
                    やっぱり静的型チェックは最高ですね。
                    それと、\@amutake氏にお願いしたら締切の2日前にもかかわらず\code(`+theorem`);と\code(`+proof`);を追加してくれました。ありがとうございます！
                }
            >
        >
    >
end
