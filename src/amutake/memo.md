# モバイルアプリからCoqを動かしたい Part 1

## 目次メモ

1. ProveEverywhereについて
1. Coqとは
1. 全体のアーキテクチャを設計する
1. プロトコルを設計する
    1. プロトコルの基本方針と要件
    1. Coq XMLプロトコルについて
1. まとめ


こんにちは。@amutakeです。
今回は『モバイルアプリからCoqを動かしたい』というタイトルで、Coqという定理証明ツールのエディタアプリを作っていく話を、3回くらいにわけて書いていこうと思っています。

## モチベーション

今回作成するアプリの名前は『ProveEverywhere』といいます。ProveEverywhereは私が学生の頃に作った、AndroidからCoqのコードが書け証明ができるアプリの名前です。
Androidアプリを作ってみようという授業があり、その授業の自由課題で作ったのですが、もう古いので作り直したいというのがモチベーションになります。

当時このアプリを作成したモチベーションはその名の通り「どこでも証明できたら嬉しいね」です。
当時、任意の命題を証明できるというバグ\footnote{\url(`https://github.com/clarus/falso`)}がCoqで見つかり、Twitter上で話題になっていたのですが、
私は電車の中にいてPCを開くわけにもいかずすぐに確かめることができなかったという経緯からこのアプリを作ろうと考えました。
(v1のスクショを貼る)

さて、これ以降、学生時代に作ったアプリとこれから作ろうとしているアプリを明示的に区別したい場合はそれぞれv1、v2と記述することにします。

ProveEverywhere v1はもう6年前のアプリで、最新のCoqで使えなくなっています。確かめてはいないですがAndroidへのアプリのインストールもできなくなっているはずです。
「ProveEverywhereの次期バージョンはないのか」と聞かれることがたまにあり、いつか書き直したいと思っていたのと、
本誌のいいネタになりそうなのでこの機会に作り直して行こうと思います。


## Coqとは

Coqとは定理証明支援器と呼ばれているシステムのひとつです。ここでは詳しく説明しませんが、プログラムの性質や数学の命題を証明できるツールだと思ってください。

Coqでは、命題を定義して、その証明の方針（タクティクといいます）を書き、Coqに伝えてやることで証明を進めていきます。タクティクによって現在の証明の状態を遷移させていくイメージです。

(ここで証明が進む様をとったスクショを2枚入れる)


(このあたりはプロトコルの設計のところで前提となる知識のみを書きたい)
例として、「PならばP」という（自明に成り立つ）命題の証明を見ていきます。

命題の定義およびその証明は以下のようになります。

```
Theorem my_thm : forall P, P -> P.
Proof.
  intros P H.
  apply H.
Qed.
```

Coq では、`.\s`がひとつのコマンドの区切りになっており、`.\s`単位でCoqに伝えていきます。これをセンテンスといいます。

CoqにはcoqtopというREPLが含まれています。このcoqtopを使って、証明の状態が変わっていくことを見ていきましょう。

```
❯ coqtop
Welcome to Coq 8.12.0 (July 2020)

Coq < Theorem my_thm : forall P, P -> P.
1 subgoal

  ============================
  forall P : Type, P -> P

my_thm < Proof.

my_thm < intros P H.
1 subgoal

  P : Type
  H : P
  ============================
  P

my_thm < apply H.
No more subgoals.

my_thm < Qed.

Coq <
```

このように、センテンスをひとつずつCoqに伝えていきます。横棒の上下にいろいろと書かれているのが現在の証明の状態で、横棒の上が前提、下が証明したいもの（ゴール）となります。タクティクを駆使することで、この証明の状態を書き換えて証明を進めていきます。

### Coqのエディタと基本機能

Coqの主なエディタには、Coq公式のCoqIDE、EmacsプラグインのProofGeneral、VSCodeプラグインのVSCoqがあります。

どれも基本的な機能として、以下の3つの機能があります。

- 証明の状態の表示
- どこまでセンテンスを読み込んだかの表示
- センテンスをひとつ進める
- センテンスをひとつ戻す
- 特定の位置まで飛ばす

これらの機能がとりあえずあると、Coqのエディタとしては最低限使えるものになります。

## アプリの仕様

まずアプリの仕様（できること）を決めていきます。

以下のようなことができるアプリにしたいです。

- Coqエディタ
  - 基本機能
    - 証明の状態の表示
    - どこまでセンテンスを読み込んだかの表示
    - センテンスをひとつ進める
    - センテンスをひとつ戻す
    - 特定の位置まで飛ばす
  - スニペット機能 (モバイルだと入力が面倒なため)
- ファイル保存・アップロード
  - ファイルリスト
  - ローカル保存
  - Gistへのアップロード・clone
    - Twitterへの投稿

なお、これらはProveEverywhereの世界で一番のヘビーユーザーである株式会社proof ninjaの@yoshihiro503さんにアドバイスをいただきました。

## Coq XMLプロトコル

Coq XMLプロトコルとは、Coqを操作するためのXML APIです。CoqIDEやVSCoqで使われています。もしかしたらProofGeneralでも使われているかもしれませんがあまり調べていません。

これは余談ですが、Coq XMLプロトコルはCoq 8.5から入った機能です。
Coq 8.5はProveEverywhere v1を作ったあとに出たバージョンなので当時はこの機能はありませんでした。
なのでProveEverywhere v1ではcoqtopを標準入出力で操作する方法を使っていました。
これは当時のProofGeneralがとっていた方法で、coqtopの`-emacs`というコマンドライン引数を使っています。`-emacs`という引数、面白いですよね。
http://amutake.hatenablog.com/entry/2014/07/07/020814

さて、Coq XMLプロトコルのドキュメントはこちらにあります。
https://github.com/coq/coq/blob/master/dev/doc/xml-protocol.md

このドキュメント、各種コマンドについての説明は充実していますが、肝心の「どのようにしてコマンドを送り、結果を受け取るか」についてはどこにも書いていません。
なので、使い方はVSCoqのソースコードを読んでエスパーしていきます。

古いCoqの場合分けがちょくちょく入っていますが、とりあえず最新のCoq（2020年9月時点でバージョン8.12が最新）で使えればいいので、最新のCoqでの方法だけまとめていきます。

参考にするのはVSCoqの`server/src/coqtop/CoqTop8.ts`というファイルです。ここに具体的にCoqを操作する実装が書かれています。
https://github.com/coq-community/vscoq/blob/master/server/src/coqtop/CoqTop8.ts

こちらには上記のクラスに渡すパラメータが書かれています。
https://github.com/coq-community/vscoq/blob/070e2e7b6a5f27df6a7ce2d0e4e80c2efde3b5e8/server/src/CoqProject.ts

### coqidetopと引数

Coq XMLプロトコルを使ってCoqを操作するには、`coqidetop`という専用のコマンドを使います。
以下が`coqidetop`を起動する際の基本的なオプションです。

```
coqidetop \
  -main-channel <MAIN_ADDR>:<MAIN_PORT_R>:<MAIN_PORT_W> \
  -async-proofs on
```

Coqとのやりとりはメインチャンネルというチャンネルを通して行います。チャンネルは、TCPあるいは標準入出力を使ってCoqとやりとりをする通信路です。読み取り用チャンネルと書き込み用チャンネルがあり、それぞれCoqからコマンドの結果を受け取るチャンネル、Coqにコマンドを伝えるチャンネルとして使います。

`-main-channel`というコマンドライン引数で指定します。例えば読み取り用チャンネルのポートが12345、書き込み用チャンネルのポートが54321、どちらもローカルホストで起動している場合は、`-main-channel 127.0.0.1:12345:54321`と指定します。標準入出力の場合は`-main-channel stdfds`と指定します。`coqidetop`を試す場合は標準入出力の方を使うと手軽に試すことができます。

メインチャンネルの他にも制御チャンネル（`-control-channel`で指定します）というチャンネルもありますが、何に使うのかいまいちよくわかりません。VSCoqを見ても、特に何かに使われているというわけではなさそうでした。なので本稿では省略します。

`-async-proofs`は非同期証明機能をオンにするかというもので、基本はオンにしておいていいと思います。
https://coq.inria.fr/refman/addendum/parallel-proof-processing.html

### コマンドとフィードバック

Coqを操作するには、書き込み用メインチャンネルに「コマンド」を書き込む必要があります。
コマンドをCoqが実行すると、コマンドの結果や「フィードバック」と呼ばれるデータが読み取り用メインチャンネルから取得することができます。

本節では、まずコマンドの理解に必要なState IDについての説明をしてから、主要なコマンドとフィードバックを説明したいきたいと思います。

#### 状態ID

各種コマンドでは状態ID（State ID）という自然数が返ってくるあるいは指定することがあります。
これは、いまどのセンテンスの位置にいるかを表すIDです。
後述するAddコマンド（センテンスの追加）やEditAtコマンド（指定した状態にジャンプ）によって「現在どの状態にいるか」が変わります。

状態IDは一度つけられると上書きされないことに注意してください。
例えば、現在状態IDが2の状態でEditAtでID1に巻き戻ると、そこからAddされてもIDは2にならず、3などまだ使われていない最も若いIDが使われます。なので状態は木構造になります。


#### Initコマンド

最初の状態IDを返します。最初に指定すべき状態IDは`coqidetop`を起動した時点ではわからないので、Initを実行して初めて知ることができます（とはいえInitを実行しなくてもいきなりID0指定でAddは実行できます）。

Initコマンドは`coqidetop`を起動してから一度しか実行できません。なので一度起動して状態を進めた`coqidetop`を初期化して使いまわすということはできません。初期化するには`coqidetop`を再起動するか、後述するEditAtを使います。

#### Addコマンド

Addコマンドは最も基本的なコマンドで、状態IDと次のセンテンスを与えて状態を進めるコマンドです。
結果には次の状態IDが含まれているので、これを指定することで状態を次へ次へと進めていくことができます。

#### EditAtコマンド

状態IDを指定して、その状態に戻るコマンドです。
なお、巻き戻したあとに巻き戻る前の状態に戻ることはできません。
つまり、現在いる状態IDよりも大きいIDにジャンプすることはできません。

#### Goalコマンド

Goalコマンドは現在の証明の状態（図）を取得するコマンドです。
Coqでは証明の状態はいくつものサブゴール（場合分けしたときの証明しなければいけない命題）に分かれているのですが、それらがリストとして返ってきます。

Addコマンドで証明を進めたあとはいちいちGoalコマンドを実行しなければ証明の状態を取得できないということになります。個人的にはAddで返ってきてもいいように思うのですがそうはなっていないようです。

#### フィードバック

各種コマンドの結果とは別に、フィードバックというデータがメインチャンネルから取得できることがあります。これは、状態IDの状態（処理中だとか完了だとか）を表すデータになります。

これ以外のコマンドは以下をご覧ください。
https://github.com/coq/coq/blob/master/dev/doc/xml-protocol.md


### チャンネルの特徴

`coqidetop`のチャンネルにんはいくつかの（残念な）特徴があります。

まずひとつめは、素早く連続で送信すると結果が返ってこないことがあることです。条件はわかりませんが、試しているとときどきコマンドの結果が歯抜けになって返ってくることがありました。

ふたつめは、連続で送信すると結果の順序が変わることがあることです。こちらは1秒程度の間隔を空けても起こったので、わりと起こりやすいのかもしれません。

このように、TCPでつないでいるとはいえCoq側でロスやリオーダーが起きてしまうようです。

## 全体のアーキテクチャの設計

この節では、アプリおよびサーバのアーキテクチャの設計について書いていこうと思います。

まず、アーキテクチャの設計する際の前提知識として必要なCoq XMLプロトコルについて書き、それを踏まえてどのようなアーキテクチャにするかを書いていきます。

よく使うと思われる最低限のコマンドだけ説明します。


### 全体のアーキテクチャの設計

図(図)のようなアーキテクチャにします。
サーバ
図
このアーキテクチャはv1と変わっていません。

他にはモバイルアプリの中にCoqを埋め込んでしまう方法もありますが、パワーがないとなかなか難しそうなので避けます。(既存のアプリを挙げる)

なお、モバイルアプリ側はFlutterで、サーバ側はGoで書こうと思っています。


## プロトコルの設計

節(番号)では、ProveEverywhere v2のアーキテクチャを、Coqを制御するサーバ、そしてそのサーバと通信をするモバイルアプリ（クライアント）、という形にしました。この節ではサーバとクライアント間のプロトコルを設計していきます。

### プロトコル基本方針と要件

通信は非同期で行いたいです。サーバと通信している最中はアプリ側がブロックされて操作できなくなると不便。
サーバ側の障害やタイムアウトがあっても問題ない

クライアント側とサーバ側で状態を同期させなければいけません。クライアント側とサーバ側で受理されているコマンドが異なると、コマンドを受け付けてもらえなくなるか、間違った結果がクライアント側に返されてしまうことになります。



#### Next, Back, Goto の実現方法

Next は Add コマンドが使えます。
Back は EditAt コマンドが使えます。
Goto は、センテンスを追加する場合は Add を連続で実行、巻き戻す場合は EditAt を実行するといいでしょう。

stateId を保持しておく必要があります。



### 面倒なパターン

WebSocketを使うので、メッセージの順序は保たれるという前提が使えます。
が、それでも面倒なパターンがいくつかあるので、各パターンについてどのような挙動が好ましいか考えていきます。

- 連続で送ったが、途中でセンテンスが失敗した
- 連続で送ったが、途中でタイムアウトになった
- 連続で送ったが、サーバ・Coq間で途中のセンテンスの結果だけ返ってこなかった
- 連続で送ったが、サーバ・Coq間でCoqに送信したセンテンスと結果の順序が入れ替わった
- 連続で送って、途中でコマンドが失敗したが、失敗したコマンドのあとに失敗してもしなくても受理されるコマンドが含まれていた
  - SuccessSentence. FailureSentence. SuccessSentence (not depend on FailureSentence). とか
  - どういう振る舞いが好ましいのか
  - 普通にそのまま送ればいいのでは。
  - state_id が変わるからそのまま送れなさそう
  - SuccessSentence. FailureSentence. EditAt. は？
  - EditAt は受理されるが
    - EditAt で、
- アプリが閉じられた
- 数時間後に再開した



### まとめ

この節では、アプリとサーバ間のプロトコルについて書いていきました。
現状はこの方針で大丈夫なんじゃないかと思っていますが、もしかすると実際にサーバとクライアントを書いているときに不都合が出て変わるかもしれません。

## おわりに

この記事ではモバイルアプリからCoqを動かしたい Part 1と題して、Coqのエディタアプリの仕様と設計を書いていきました。特にCoq XMLプロトコルについては日本語では一番詳しい記事なのではないかと思います。非常にニッチな話題なのでCoq XMLプロトコルを詳しく知りたい人がいる気はしませんが、参考になれば幸いです。

次回はサーバ側の実装について書いていきたいと思いますので、ぜひ楽しみにしていてください。


# メモ

- サーバ側は自前実装せず、vscoqを使えばいい気がしてきた
    - 自前実装じゃないといけない理由はあるだろうか
    - language-server との変換部分でなんとかすればいいのでは
