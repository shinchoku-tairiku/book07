# モバイルアプリからCoqを動かしたい Part 1

## 目次メモ

1. ProveEverywhereについて
1. Coqとは
1. 全体のアーキテクチャを設計する
1. プロトコルを設計する
    1. プロトコルの基本方針と要件
    1. Coq XMLプロトコルについて
1. まとめ


こんにちは。@amutakeです。
今回は『モバイルアプリからCoqを動かしたい』というタイトルで、Coqという定理証明ツールのエディタアプリを作っていく話を、3回くらいにわけて書いていこうと思っています。

## モチベーション

今回作成するアプリの名前は『ProveEverywhere』といいます。ProveEverywhereは私が学生の頃に作った、AndroidからCoqのコードが書け証明ができるアプリの名前です。
Androidアプリを作ってみようという授業があり、その授業の自由課題で作ったのですが、もう古いので作り直したいというのがモチベーションになります。

当時このアプリを作成したモチベーションはその名の通り「どこでも証明できたら嬉しいね」です。
当時、任意の命題を証明できるというバグ\footnote{\url(`https://github.com/clarus/falso`)}がCoqで見つかり、Twitter上で話題になっていたのですが、
私は電車の中にいてPCを開くわけにもいかずすぐに確かめることができなかったという経緯からこのアプリを作ろうと考えました。
(v1のスクショを貼る)

さて、これ以降、学生時代に作ったアプリとこれから作ろうとしているアプリを明示的に区別したい場合はそれぞれv1、v2と記述することにします。

ProveEverywhere v1はもう6年前のアプリで、最新のCoqで使えなくなっています。確かめてはいないですがAndroidへのアプリのインストールもできなくなっているはずです。
「ProveEverywhereの次期バージョンはないのか」と聞かれることがたまにあり、いつか書き直したいと思っていたのと、
本誌のいいネタになりそうなのでこの機会に作り直して行こうと思います。


## Coqとは

Coqとは定理証明支援器と呼ばれているシステムのひとつです。ここでは詳しく説明しませんが、プログラムの性質や数学の命題を証明できるツールだと思ってください。

Coqでは、命題を定義して、その証明の方針（タクティクといいます）を書き、Coqに伝えてやることで証明を進めていきます。タクティクによって現在の証明の状態を遷移させていくイメージです。

(ここで証明が進む様をとったスクショを2枚入れる)


(このあたりはプロトコルの設計のところで前提となる知識のみを書きたい)
例として、「PならばP」という（自明に成り立つ）命題の証明を見ていきます。

命題の定義およびその証明は以下のようになります。

```
Theorem my_thm : forall P, P -> P.
Proof.
  intros P H.
  apply H.
Qed.
```

Coq では、`.\s`がひとつのコマンドの区切りになっており、`.\s`単位でCoqに伝えていきます。これをセンテンスといいます。

CoqにはcoqtopというREPLが含まれています。このcoqtopを使って、証明の状態が変わっていくことを見ていきましょう。

```
❯ coqtop
Welcome to Coq 8.12.0 (July 2020)

Coq < Theorem my_thm : forall P, P -> P.
1 subgoal

  ============================
  forall P : Type, P -> P

my_thm < Proof.

my_thm < intros P H.
1 subgoal

  P : Type
  H : P
  ============================
  P

my_thm < apply H.
No more subgoals.

my_thm < Qed.

Coq <
```

このように、センテンスをひとつずつCoqに伝えていきます。横棒の上下にいろいろと書かれているのが現在の証明の状態で、横棒の上が前提、下が証明したいもの（ゴール）となります。タクティクを駆使することで、この証明の状態を書き換えて証明を進めていきます。

### Coqのエディタと基本機能

Coqの主なエディタには、Coq公式のCoqIDE、EmacsプラグインのProofGeneral、VSCodeプラグインのVSCoqがあります。

どれも基本的な機能として、以下の3つの機能があります。

- 証明の状態の表示
- どこまでセンテンスを読み込んだかの表示
- センテンスをひとつ進める
- センテンスをひとつ戻す
- 特定の位置まで飛ばす

これらの機能がとりあえずあると、Coqのエディタとしては最低限使えるものになります。

## アプリの仕様

まずアプリの仕様（できること）を決めていきます。

以下のようなことができるアプリにしたいです。

- Coqエディタ
  - 基本機能
    - 証明の状態の表示
    - どこまでセンテンスを読み込んだかの表示
    - センテンスをひとつ進める
    - センテンスをひとつ戻す
    - 特定の位置まで飛ばす
  - スニペット機能 (モバイルだと入力が面倒なため)
- ファイル保存・アップロード
  - ファイルリスト
  - ローカル保存
  - Gistへのアップロード・clone
    - Twitterへの投稿

なお、これらはProveEverywhereの世界で一番のヘビーユーザーである株式会社proof ninjaの@yoshihiro503さんにアドバイスをいただきました。

## 全体のアーキテクチャの設計

この節では、アプリおよびサーバのアーキテクチャの設計について書いていこうと思います。

まず、アーキテクチャの設計する際の前提知識として必要なCoq XMLプロトコルについて書き、それを踏まえてどのようなアーキテクチャにするかを書いていきます。

### Coq XMLプロトコル

Coq XMLプロトコルとは、Coqを操作するためのXML APIです。CoqIDEやVSCoqで使われています。もしかしたらProofGeneralでも使われているかもしれませんがあまり調べていません。

これは余談ですが、Coq XMLプロトコルはCoq 8.5から入った機能です。
Coq 8.5はProveEverywhere v1を作ったあとに出たバージョンなので当時はこの機能はありませんでした。
なのでProveEverywhere v1ではcoqtopを標準入出力で操作する方法を使っていました。
これは当時のProofGeneralがとっていた方法で、coqtopの`-emacs`というコマンドライン引数を使っています。`-emacs`という引数、面白いですよね。
http://amutake.hatenablog.com/entry/2014/07/07/020814

さて、Coq XMLプロトコルのドキュメントはこちらにあります。
https://github.com/coq/coq/blob/master/dev/doc/xml-protocol.md

このドキュメント、各種コマンドについての説明は充実していますが、肝心の「どのようにしてコマンドを送り、結果を受け取るか」についてはどこにも書いていません。
なので、使い方はVSCoqのソースコードを読んでエスパーしていきます。

古いCoqの場合分けがちょくちょく入っていますが、とりあえず最新のCoq（2020年9月時点でバージョン8.12が最新）で使えればいいので、最新のCoqでの方法だけまとめていきます。

参考にするのはVSCoqの`server/src/coqtop/CoqTop8.ts`というファイルです。ここに具体的にCoqを操作する実装が書かれています。
https://github.com/coq-community/vscoq/blob/master/server/src/coqtop/CoqTop8.ts

こちらには上記のクラスに渡すパラメータが書かれています。
https://github.com/coq-community/vscoq/blob/070e2e7b6a5f27df6a7ce2d0e4e80c2efde3b5e8/server/src/CoqProject.ts


メインチャンネル、制御チャンネルがあるようです。

```
coqidetop \
  -topfile <FILE> \
  -main-channel <MAIN_ADDR>:<MAIN_PORT_R>:<MAIN_PORT_W> \
  -control-channel <CTRL_ADDR>:<CTRL_PORT_R>:<CTRL_PORT_W> \
  -async-proofs on
```

制御チャンネルは何に使うのかいまいちよくわかりません。



coqidetopの特徴

- 素早く連続で送信すると結果が返ってこないことがある
- (そんなに素早くなくても) 連続で送信すると結果の順序が変わることがある
  - About About Init した結果が About Init About になったりした

というなかなか面倒な特徴を持っています。
なので、サーバ側で順序を整えて返したいです。

よく使うと思われる最低限のコマンドだけ説明します。

-

### 全体のアーキテクチャの設計

図(図)のようなアーキテクチャにします。
サーバ
図
このアーキテクチャはv1と変わっていません。

他にはモバイルアプリの中にCoqを埋め込んでしまう方法もありますが、パワーがないとなかなか難しそうなので避けます。(既存のアプリを挙げる)

なお、モバイルアプリ側はFlutterで、サーバ側はGoで書こうと思っています。


## プロトコルの設計

節(番号)では、ProveEverywhere v2のアーキテクチャを、Coqを制御するサーバ、そしてそのサーバと通信をするモバイルアプリ（クライアント）、という形にしました。この節ではサーバとクライアント間のプロトコルを設計していきます。

### プロトコル基本方針と要件

通信は非同期で行いたいです。サーバと通信している最中はアプリ側がブロックされて操作できなくなると不便。
サーバ側の障害やタイムアウトがあっても問題ない

クライアント側とサーバ側で状態を同期させなければいけません。クライアント側とサーバ側で受理されているコマンドが異なると、コマンドを受け付けてもらえなくなるか、間違った結果がクライアント側に返されてしまうことになります。



#### Next, Back, Goto の実現方法

Next は Add コマンドが使えます。
Back は EditAt コマンドが使えます。
Goto は、センテンスを追加する場合は Add を連続で実行、巻き戻す場合は EditAt を実行するといいでしょう。

stateId を保持しておく必要があります。



### 面倒なパターン

WebSocketを使うので、メッセージの順序は保たれるという前提が使えます。
が、それでも面倒なパターンがいくつかあるので、各パターンについてどのような挙動が好ましいか考えていきます。

- 連続で送ったが、途中でセンテンスが失敗した
- 連続で送ったが、途中でタイムアウトになった
- 連続で送ったが、サーバ・Coq間で途中のセンテンスの結果だけ返ってこなかった
- 連続で送ったが、サーバ・Coq間でCoqに送信したセンテンスと結果の順序が入れ替わった
- 連続で送って、途中でコマンドが失敗したが、失敗したコマンドのあとに失敗してもしなくても受理されるコマンドが含まれていた
  - SuccessSentence. FailureSentence. SuccessSentence (not depend on FailureSentence). とか
  - どういう振る舞いが好ましいのか
  - 普通にそのまま送ればいいのでは。
  - state_id が変わるからそのまま送れなさそう
  - SuccessSentence. FailureSentence. EditAt. は？
  - EditAt は受理されるが
    - EditAt で、
- アプリが閉じられた
- 数時間後に再開した



### まとめ

この節では、アプリとサーバ間のプロトコルについて書いていきました。
現状はこの方針で大丈夫なんじゃないかと思っていますが、もしかすると実際にサーバとクライアントを書いているときに不都合が出て変わるかもしれません。

## おわりに

この記事ではモバイルアプリからCoqを動かしたい Part 1と題して、Coqのエディタアプリの仕様と設計を書いていきました。特にCoq XMLプロトコルについては日本語では一番詳しい記事なのではないかと思います。非常にニッチな話題なのでCoq XMLプロトコルを詳しく知りたい人がいる気はしませんが、参考になれば幸いです。

次回はサーバ側の実装について書いていきたいと思いますので、ぜひ楽しみにしていてください。


# メモ

- サーバ側は自前実装せず、vscoqを使えばいい気がしてきた
    - 自前実装じゃないといけない理由はあるだろうか
    - language-server との変換部分でなんとかすればいいのでは
