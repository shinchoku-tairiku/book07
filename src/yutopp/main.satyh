@import: ../../shinchoku-tairiku.satyh/shinchoku-tairiku

let-block +code label code caption = '<
  +code?:(`yutopp:code:` ^ label)(code){#caption;}
>

let-block +yutopp = '<+chapter{自作言語改造日誌2020}{謎の名言絶対にいる}<

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+section{はじめに}<

+p {
  こんにちは、\@yutoppです。今回は読み物として記事を書きたいと思います。
}

+p {
 さて皆さんはプログラミング言語の自作はお好きでしょうか。私は割と好きでして、趣味で自作言語を実装しては行き詰まってというのを繰り返しています。
}

+p {
  趣味開発で好き勝手に実装するのは非常に楽しいものでして、今まで自作言語には既存の汎用言語の気になった機能をとりあえず実装してみるというのをやっていました。一方で、既存の汎用言語というのは、それまでの経験や資産を活かして言語機能のトレードオフや互換性の維持に非常に気を使って作られているものと思います。その一箇所のみを切り取って車輪の再発明をすると大量の歪みによって†破滅†が待ち構えております。
}

+p {
以下では、これらの教訓から得られた実感を踏まえて、自作言語の再設計について、また各機能のトレードオフの感想を述べていきたいと思います。プログラミング言語の自作に興味のある方に、共感ネタとして楽しんでいただけると幸いです。
}

+p {
(この記事中に様々な言語機能の話が登場しますが、それらによって言語の良し悪しを主張つもりはなく、異なる前提の下で自身の言語に実装するにあたって考え直すならばどういった選択をし直すかということのみを主張しているつもりです。)
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+section{背景}<

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{これまでの振り返り}<

+p {
自作言語の名前はRill(a.k.a.文鳥言語)というものを作っています。コミットログを見ると2013年からいじっているらしい(古くてびびる)。その当時はC++やDの影響を強く受けていて、ネイティブで動かすことを前提にコンパイル時の自由さとランタイムのコンパクトさを目指す言語というコンセプトで作り始めました。テンプレートやクラス、各種コンストラクタやデストラクタ、コンパイル時間数実行を実装してあります。
}

+p{
コード貼る。
}

+p {
また途中にRustにも影響を受け、lifetimeに限りgenericsを盛り込むなどの実装をしていたところ、ある日処理系の実装の複雑度が自身の脳のキャパシティを超えメンテが不可能になり†破滅†が訪れました。
}

+p {

2017年あたりからRillの実装とは独立して、中間表現を設計してバックエンドを単純化したり\footnote{進捗大陸03}、ML系の小さい型チェッカを作成したりと、大きな機能を細かくなるべく体系だった形で実装できるような方針で再設計を始めてみました。

}

+p {
また、2019年あたりにはLSP対応の言語処理系を作る実験もしました\footnote{進捗大陸05}。LSPというのは簡単に言うとエラーや型、補完情報などをやりとりするプロトコルです。一般には言語ごとのLSPサーバープログラムを立ち上げておいて、それでエディタなどから編集途中のソースコードを受け取りつつ構文解析や意味解析を行って上記の結果をやりとりします。
}

+p {
このLSPサーバーの応答が高速になると、サクサクと補完を効かせながら実装を快適に進めることができます。この体験は最高なので、言語フロントエンド(構文解析・意味解析)も高速に実行できる程度の複雑さに抑えるという方針も立てました。
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{改造開始}<

+p {
背景として、問題意識を意味解析・コード生成のフローが複雑になりすぎていたことを解消したいという点におくことにします。
}

+p {

- コンパイル時の計算はなるべく抑える。
- 前段のフローでは抽象的な解析に抑える。
- 具体的な実装に頼らず、型や性質などの粒度の大きい情報を活用する。
- 言語コア機能は本当に小さく

という点を意識して自作言語本体を作り直していきます。古くから活躍している言語が互換性の問題で手こずっている(であろう)言語機能も、自作言語ならば互換性を取っ払って解決可能という点がいいところですね！
}

+p {
これらの問題意識はほぼ全て先人により踏破されている問題でもあるので、これから実装をする方は予めあたりをつけて調べておくと良さそうにも思います。ただ、実装して踏み抜くことでより身に沁みて深く問題を味わえるのは経験になると信じたいですね…
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+section{設計と進化(？)}<

+p {
構文解析から意味解析・コード生成まで。設計から実装手法まで大まかに説明する。
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{TemplateからGenericsへ}<

+p {
まずtemplate機能についてはC++やDが有名なのではないでしょうか。C++では依存名などの区別を行いつつ意味解析を行っておき、インスタンス化の際に実際の型引数の情報を用いて再度それぞれ型検査を行っているような振る舞いをします。
}

+code(`template,c++`)(```
template<typename T>
int f(T a) {
    a * a;
    m a; // エラー: インスタンス化の前に、templateに依存していない識別子(m)のルックアップを解析
}
```){}

+p {
Dに至ってはテンプレートの中身は意味解析時に完全にノータッチで、インスタンス化と同時にそのパラメータを用いてASTを再解釈しているような振る舞いをします。
}


+code(`template,d`)(```
void f(T)(T a) {
    a * a;
    m a; // OK: mが存在しようともしなくとも、インスタンス化までノータッチ
}
```){}

+p{
自作言語では、Dの振る舞いを参考にしてテンプレートを実装していました。マルチパスの意味解析の1パス目でテンプレートはASTの構造の状態で保持し、中身は一切無視をします。インスタンス化が発生した段階で、引数の型情報を渡してASTの意味解析を行います。意味解析に成功すればそのままmixinを行い、関数であれば通常のオーバーロード解決の候補に入れます。意味解析に失敗した場合は、そのままコンパイルエラーとしていました\footnote{これは、最終的にDのmixinや__traitを実現するためにこのようにしていました。}。透過的な構文で非常に自由度の高いメタプログラミングが行えます。多相も静的に解決されるため実行時のオーバヘッドもありません。
}

+p{
この手法の代償は、インスタンス化のたびに意味解析を行い直す必要があります。これはビルドの実行時間に影響があります。(キャッシュなどの話をのせる)。透過的なコンパイル時時間数実行の機能と合わさると、意味解析中に構文解析からコード生成までも含めて何度も行わなくてはなりません。加えて、テンプレート内部に関してもインスタンス化をするまで何も情報を決定することもできません。コンパイラのフローは複雑になるし、補完と行った観点から見てもかなり工夫が必要になりそうです。
}

+p{フローの図}

+p{
そこで、templateからgenericsへ実装を転換しました。genericsは、意味解析の段階ですぐさまその時点の制約の情報を用いて内容の解析を行います。
}

+code(`generics,rill`)(```
def f!(T)(a: T) {
    a * a; // エラー: T型に*演算を行える制約がない
}
```){}

+p{
そのため、上記のようなコードは意味解析を通らなくなります。これは、この時点ではTがどのようなことができるかもわからないためです。
}
+code(`generics,rill2`)(```
def f!(T: Mul)(a: T) { // Mulは*演算を行える制約
    a * a; // OK
}
```){}
+p{
先程のコードのエラーを消すためには、このようにこの時点でTは掛け算を行えますといった制約をつけていくことになります。
}
+p{
Genericsを採用している汎用プログラミング言語を挙げると、Java,C\#,Rust,Go(予定)、Swift、TypeScript,ML系などがあり、一般にメジャーな印象があります。
}
+p {
当時、Genericsを採用した言語のコード生成というのは動的なディスパッチのイメージが強く、実行時にオーバヘッドが発生することを嫌い採用していませんでした(完全に調査不足ですね…)。
}
+code(`generics,nanika`)(```
dynamic dispatchになりそうなコード乗せる
```){}
+p{
この課題を解決する方法として単一化(monomorphization)というものがあります。これはどういうことかというと、意味解析はすでに行った上で、コード生成の段階で静的に判明している型を用いてそれぞれのgenerics関数を複製し静的な呼び出しに変換します。最適化の一種として行われる場合もあれば、RustやHaskellのように言語機能で強制できるものも存在ます。
}
+p{
つまりはgenericな関数をコード生成時にtemplateのインスタンス化するようなイメージです。オーバーヘッドのないtemplate相当の機能を、コード生成の段階まで遅らせることができます。嬉しいですね。コードの複製はコードサイズや全体のコンパイル時間の増加にも繋がりますが、これはtemplateのときには常につきまとっていた問題なのでより悪くなっていることはないでしょう。
}
+p{フローの図}
+p{
自由さを手放しすこし行儀を良くすることで意味解析のフローをかなり整理することができました。失われたコンパイル時機能の代案は、マクロやdirectiveによるコンパイラスイッチなど意味解析とはフローを分けて行えるもので再度導入したいと考えています。
}

>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{オーバーロードから型クラス(trait)へ}<

+p {
オーバロードも様々な言語で取り入れられている概念だと思いますが、ここでもC++やDのようなものを想像してください。
}

+code(`overload,adhoc`)(```
foo(10);
foo("abc");

void foo(int);
void foo(string);
```){}

+p{
のような形で同じ名前で定義した関数を型によって呼びかえる機能ですね。1つ目のtemplate/genericsはパラメトリック多相。こちらのオーバロードはアドホック多相と呼ばれます。
さて、上記でお行儀よくgenericsにしましたが、これはオーバロードと相性が悪いように思います。
}

+code(`overload,adhoc,ts`)(```
function f<T>(a: T) {
    g(a);
}

function g(_: number): void;
function g(_: string): void;
function g(_: any) {}
```){}

+p{
まず、fのようなgeneric関数のTのパラメータの情報だけではgの関数のどのオーバーロードにマッチをするのか静的に決定できません。同様の理由で、型推論でも型を定めることができず相性が悪いです[要出典、書き足す]。
}

+p {
これらは型クラス(ここではtraitと書きます)を導入することでも実現できます。
}

+code(`generics,type-class`)(```
// FooAble 'a のような暗黙の型パラメータaを持つ型の型のようなもの
trait FooAble {
  // a -> ()
  def foo(self)
}
impl FooAble for int {
  // int -> ()
  def foo(self) {}
}
impl FooAble for string {
  // string -> ()
  def foo(self) {}
}
FooAble::foo(10);
FooAble::foo("abc");
```){}

+p{
genericsでは、以下のようにかけるようになります。
}

+code(`generics,nanika`)(```
def foo!(T: FooAble)(T a) {
  T::foo(a)
}
```){}

+p{
これで、現時点でTはFooを呼べることを仮定して意味解析をすることができます。

型クラスの実装方法\footnote{\url(`http://okmij.org/ftp/Computation/typeclass.html`);}としては、dictionary passing styleなどが有名です。この方法はC++でいるvtableのような関数テーブル(辞書)をひきまわす方法です。Haskellなどが採用しています。
}

+code(`generics,nanika`)(```
コード編
```){}

+p {
自作言語では、Intensional type analysisという手法で行いました。おそらくこれはより原始的な方法で、型の一致を別途解析によって探索するような方法です。Scalaのimplicitsの探索はこの方法のようです。
}

+p {
自作言語では現状すべて単一化を行っているので、その際に静的にtableを探して埋め込めるはずです。
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{クラスから単純な構造体へ}<

+p {
C++のクラスはとても複雑です。C++ではクラスのデフォルト・コピー・ムーブ・ユーザー定義コンストラクタのオーバーロードやデストラクタなどがあり、これらを参考して実装するととても複雑になります。また、オブジェクトにはtrivialであったりstandard-layoutになるであったりのいろいろな区分があり、このあたりのオーバロード加減で性質が変わります。memcopyできたりなど。
}

+p {
そういったものは明示的に行いましょうということでクラスといった役割を持たせることはやめました。純粋な構造体としてデータだけを持ちます。
静的なメンバ関数はimplなどで別途実装させます。動的なメンバはtraitとトレイとオブジェクトによるvtableの生成に任せて分離します。これにより
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+section{おわりに}<

+p{
ア！
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>>
