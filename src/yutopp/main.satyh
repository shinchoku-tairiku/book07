@import: ../../shinchoku-tairiku.satyh/shinchoku-tairiku

let-block +code label code caption = '<
  +code?:(`yutopp:code:` ^ label)(code){#caption;}
>

let-block +figure label size caption = '<
  +figure?:(`yutopp:figure:` ^ label)?:(size)(`yutopp/` ^ label ^ `.pdf`){#caption;}
>

let-block +yutopp = '<+chapter{自作言語改造日誌2020}{謎の名言絶対にいる}<

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+section{はじめに}<

+p {
  こんにちは、\@yutoppです。今回は読み物として記事を書きたいと思います。
}

+p {
 さて皆さんはプログラミング言語の自作はお好きでしょうか。私は割と好きでして、趣味で自作言語を実装しては行き詰まってというのを繰り返しています。
}

+p {
  趣味開発で好き勝手に実装するのは非常に楽しいものでして、今まで自作言語には既存の汎用言語の気になった機能をとりあえず実装してみるというのをやっていました。
  一方で、既存の汎用言語というのはこれまでの歴史や資産を活かし言語機能の取捨選択や互換性の維持に非常に気を使って作られているものと思います。
  その一箇所のみを切り取って車輪の再発明をすると、大量の歪みによって†破滅†が待ち構えております。
}

+p {
以下では、これらの教訓から得られた実感を踏まえて、自作言語の再設計について、また各機能のトレードオフの感想を述べていきたいと思います。プログラミング言語の自作に興味のある方に、共感ネタとして楽しんでいただけると幸いです。
}

+p {
(この記事中に様々な言語機能の話が登場しますが、それらによって言語の良し悪しを主張するつもりはなく、異なる前提の下で自身の言語に機能を実装するにあたって考え直すならばどういった選択をするかという観点の説明のみを意図しています。)
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+section{背景}<

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{これまでの振り返り}<

+p {
  自作言語の名前はRill (a.k.a.文鳥言語)\footnote{\url(`https://github.com/yutopp/rill`);}というものを作っています。コミットログを見ると2013年からいじっているらしいものです(古くてびっくりですね)。その当時はC++やDの影響を強く受けていて、ネイティブで動かすことを前提にコンパイル時の自由さとランタイムのコンパクトさを目指す言語というコンセプトで作り始めました。テンプレートやクラス、各種コンストラクタやデストラクタ、コンパイル時間数実行を実装してあります。
}

+code(`template,rill,fib`)(```
import std.stdio;
import std.assert;

def main() {
    meta s = 40;
    meta a = fib!(s)();
    assert( a == 102334155 );
    a.print();
}

def fib!(v: int32)(): int32 when v == 0 {
    return 0;
}

def fib!(v: int32)(): int32 when v == 1 {
    return 1;
}

def fib!(v: int32)(): int32 when v >= 2 {
    meta r = fib!(v-1)() + fib!(v-2)();
    return r;
}
```){自作言語でのfibのコンパイル時計算(テンプレート+オーバーロード)}

+p {
また途中でRustにも影響を受け、lifetimeに限りgenericsを盛り込むなどの実装をしていたところ、ある日処理系の実装の複雑度が自身の脳のキャパシティを超えメンテが不可能になり†破滅†が訪れました。
}

+p {
2017年頃よりRillの実装とは独立して、中間表現を設計してバックエンドを単純化したり\footnote{進捗大陸03: LLVMで作り直す自作言語入門 / \url(`https://shinchoku-tairiku.github.io/web/books/tairiku03/`);}、ML系の小さい型検査器を作成したりと、大きな機能を細かくなるべく体系だった形で実装できるような方針で再設計を始めてみました。
}

+p {
また、2019年頃にはLSP対応の言語処理系を作る実験もしました\footnote{進捗大陸05: LSP 対応言語処理系つくってみた / \url(`https://shinchoku-tairiku.github.io/web/books/tairiku05/`);}。LSPというのは簡単に言うとエラーや型、補完情報などをやりとりするプロトコルです。一般には言語ごとのLSPサーバープログラムを立ち上げておいて、それでエディタなどから編集途中のソースコードを受け取りつつ構文解析や意味解析を行って上記の結果をやりとりします。
}

+p {
このLSPサーバーの応答が高速になると、サクサクと補完を効かせながら実装を快適に進めることができます。この体験は最高なので、言語フロントエンド(構文解析・意味解析)も高速に実行できる程度の複雑さに抑えるという方針も立てました。
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{改造開始}<

+p {
問題意識は、意味解析・コード生成のフローが複雑になりすぎていたことを解消したいという点にあります。よって、これからの機能の作り直し\footnote{作り直し中の作業ブランチ: \url(`https://github.com/yutopp/rill/tree/next`);}には以下のような前提を置くことにしました。
}

+listing {
  * 個々のフローでは抽象的な解析に抑える(フローを跨いで具体的な値の計算をしない)
  * 型や性質などの粒度の大きい情報を活用する
  * 言語コア機能は本当に小さく
}

+p {
古くから活躍している言語が互換性の問題で手こずっている(であろう)言語機能も、自作言語ならば互換性を取っ払って解決可能という点がいいところですね！
}

+p {
これらの問題意識はほぼ全て先人により踏破されてきた問題でもあるので、これから実装をする方は予めあたりをつけて調べておくと良さそうにも思います。ただ、実装して踏み抜くことでより身に沁みて深く問題を味わえるのは経験になると信じたいですね…
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+section{設計と進化(？)}<


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{templateからgenericsへ}<

+p {
まずtemplate機能についてはC++やDが有名なのではないでしょうか。C++では依存名などの区別を行いつつ意味解析を行っておき、インスタンス化の際に実際の型引数の情報を用いて再度それぞれ型検査を行っているような振る舞いをします。
}

+code(`template,c++`)(```
template<typename T>
int f(T a) {
    a * a;
    m a; // エラー: インスタンス化の前に、templateに依存していない識別子(m)のルックアップを解析
}
```){C++のテンプレート}

+p {
Dに至ってはテンプレートの中身は意味解析時に完全にノータッチで、インスタンス化と同時にそのパラメータを用いてASTを再解釈しているような振る舞いをします。
}

+code(`template,d`)(```
void f(T)(T a) {
    a * a;
    m a; // OK: mが存在しようともしなくとも、インスタンス化までノータッチ
}
```){Dのテンプレート}

+p{
自作言語では、Dの振る舞いを参考にしてテンプレートを実装していました。マルチパスの意味解析の1パス目でテンプレートをASTの構造の状態で保持し、中身は一切無視をします。インスタンス化が発生した段階で、引数の型情報を渡してASTの意味解析を行います。意味解析に成功すればそのままmixinを行い、関数であれば通常のオーバーロード解決の候補に入れます。意味解析に失敗した場合は、そのままコンパイルエラーとしていました\footnote{将来的にDのmixinや__traitを実現するために仮にこのようにしていました。}。
}

+p{このtemplateは透過的な構文で非常に自由度の高いメタプログラミングが行えます。多相も静的に解決されるため実行時のオーバヘッドもありません。
}

+p{
この手法の代償として、インスタンス化のたびに意味解析を行い直す必要があります。これはコンパイルの実行時間に影響があります\footnote{インスタンス化した型でキャッシュを行うなどの実装をすると改善はしますが、根本的に複雑な処理のため負荷になります}。
透過的なコンパイル時関数実行の機能と合わさると、意味解析中に構文解析からコード生成までも含めて何度も行わなくてはなりません。加えて、テンプレート本体に関してもインスタンス化をするまで何も情報を決定することもできません。これではコンパイラのフローは複雑になるし、コード補完を高速に動かしたいという観点から見てもかなり工夫が必要になりそうです。
}

+figure(`flow-template`)(12cm){テンプレートをインスタンス化するフロー}

+p{
そこで、自作言語ではtemplateからgenericsへ実装を転換することにしました。
}

+p{genericsは意味解析の段階ですぐさまその時点の型の制約の情報を用いて本体の処理を行います。}

+code(`generics,rill`)(```
def f!(T)(a: T) {
    a * a; // エラー: T型に*演算を行える制約がない
}
```){自作言語のgenerics}

+p{
そのため、上記のようなコードは意味解析を通らなくなります。これは関数f本体の解析の時点ではT型の値はどのような振る舞いが可能か分からないためです。
}

+p{
このコードのエラーを解消するには、以下のようにTの型に"掛け算を行えます"といった制約をつけていく方針になります。
}

+code(`generics,rill2`)(```
def f!(T: Mul)(a: T) { // Mulは*演算を行える制約
    a * a; // OK
}
```){自作言語の制約付きgenerics}

+p{
genericsを採用している汎用プログラミング言語を挙げると、Java、C\#、Rust、Go(導入予定)、Swift、TypeScript、ML系などあり、主流の言語機能といった印象があります。
}

+p {
自作言語に多相を実装した当時、genericsを採用した言語のコード生成というのは動的なディスパッチのイメージが強く、実行時にオーバヘッドが発生することを嫌って採用していませんでした(完全に調査不足ですね…)。
}

+code(`generics,nanika`)(```
public static void f<T>(T a) { // Tはobjectという制約によって参照型となる
    a.ToString(); // ToStringは仮想関数として動的なディスパッチのはず
}
```){C\#の実行時にオーバヘッドが発生しそうな関数}

+p{
この課題を解決する方法として単相化(monomorphization)というものがあります。これは何かというと、意味解析はすでに行った上で、コード生成の段階で静的に判明している型を用いてそれぞれの多相関数を複製し、静的な呼び出しに変換してしまうことです。最適化の一種として行われる場合もあれば、RustやHaskellのように言語機能で指定できるものも存在します。
}

+row{|
  \minipage(0.48)<
+code(`generics,not-mono`)(```
f(10);
f("a");

def f!(T: Mul)(a: T) {
    a * a; // OK
}
```){多相関数と呼び出し}
  >
| \minipage(0.48)<
+code(`generics,mono`)(```
f::<i32>(10);
f::<string>("a");

// コード生成時に複製
def f::<i32>(a: i32) {
    a * a;
}
def f::<string>(a: string) {
    a * a;
}
```){多相関数と単相化}
  >
|}

+p{
つまりはgenericな関数をコード生成時にtemplateのインスタンス化するようなイメージです。オーバーヘッドのないtemplate相当の機能を、コード生成の段階まで遅らせることができます。嬉しいですね。コードの複製はコードサイズやコード生成時間の増加にも繋がりますが、これはtemplateのときにも常につきまとっていた問題なのでより悪くなっていることはないでしょう。
}

+figure(`flow-simple`)(12cm){多相システムの複雑さを閉じ込めた図}

+p{
自由さを手放しすこし行儀を良くすることで意味解析のフローをかなり整理することができました。失われたコンパイル時機能の代案は、マクロやdirectiveによるコンパイラスイッチなど意味解析とはフローを分けて行えるもので再度導入したいと考えています。
}

>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{オーバーロードから型クラス(trait)へ}<

+p {
オーバロードも様々な言語で取り入れられている概念だと思いますが、ここでもC++やDのようなものを想像してください。
}

+code(`overload,adhoc`)(```
foo(10);
foo("abc");

void foo(int);
void foo(string);
```){同名のfooという関数がオーバロード(多重に定義)されている様子}

+p{
同じ名前で異なる実装の関数を多重に定義することができ、関数の呼び出し時には型によって適切に異なる実装を選択できる機能ですね。前節のtemplate/genericsはパラメトリック多相。こちらのオーバロードはアドホック多相と呼ばれます。
}
+p{
さて、templateはお行儀よくgenericsに置き換えてしまいましたが、これはオーバロードと相性が悪いように思います。
}

+code(`overload,adhoc,ts`)(```
function f<T>(a: T) {
    g(a); // Tの制約のみでどのgが呼び出せる…？
}

function g(_: number): void;
function g(_: string): void;
function g(_: any) {}
```){TypeScriptのgenericsとオーバーロード}

+p{
まず、fのような多層関数のTのパラメータの情報だけでは、gの関数のどのオーバーロードにマッチをするのか静的に決定できません。これでは、少々使い勝手がよくありません。
}

+p {
さて、このアドホック多相というのは、型クラス\footnote{\url(`https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf`);}といったものでも解決することができます。
}

+p {
自作言語でも、型クラス(ここではtraitと書きます)を導入することで上記の問題の解決を図ることにしました。
}

+code(`generics,type-class`)(```
// FooAble<a>のような暗黙の型パラメータaを持つ"型の型"のようなもの
trait FooAble {
  // a -> ()
  def foo(self)
}
impl FooAble for i32 {
  // int -> ()
  def foo(self) {}
}
impl FooAble for string {
  // string -> ()
  def foo(self) {}
}

FooAble::foo(10);
FooAble::foo("abc");
```){自作言語の型クラスとインスタンスのコード片}

+p{
また、genericsではオーバーロードの解決を以下のように書けるようになります。前節のgenericsの節で登場したMulと同じですね。
}

+code(`generics,nanika`)(```
def foo!(T: FooAble)(T a) {
  // 現時点でTは関数fooを呼べることを仮定して意味解析をすることができる
  T::foo(a)
}
```){自作言語の型クラスを用いた多相関数}

+p{
型クラスのオーバーロード解決の実装方法\footnote{\url(`http://okmij.org/ftp/Computation/typeclass.html`);}としては、dictionary passing styleなどが有名です。この方法はC++でいうvtableのような仮想関数テーブル(辞書)をひきまわす方法です。Haskellなどが採用しています。
}

+row{|
  \minipage(0.48)<
+code(`haskell,typeclass,giji`)(```
class FooAble a where
  foo :: a -> ()

instance FooAble Int where
  foo a  = ()

foo(10)
```){型クラスの疑似コード}
  >
| \minipage(0.48)<
+code(`haskell,typeclass,giji-dict`)(```
data FooAbleD a = FooAbleDict (a -> ())
foo (FooAbleDict f) a = f a

FooAbleDInt = FooAbleDict (\a -> ())

foo FooAbleDInt 10
```){型クラスのdictionary passing styleでの実装}
  >
|}

+p {
一方、自作言語ではIntensional type analysisという手法で行いました。これはおそらくより原始的な方法で、型の一致を別途解析によって探索するような方法です。Scalaのimplicitsの探索はこの方法のようです。
}

+code(`haskell,typeclass,giji-dict`)(```
// 型の判別によって実装を振り分けられる何かしら持っておく。
// Mapで持っても良いし、switchで分岐してもよい。ADTで分岐してもなんでもよい。

// 自作言語では、コード生成時に型と実装の対応を収集してMapで持っておく。
// let fooOverloads = new Map<type, fooTable>();
// fooOverloads[typeof(i32)] = fooInt

// FooAble::foo(10)
// ↓ 10はi32型ということはコード生成時に判明しているので、
// 　 実装の対応から型に適したものを*コンパイル時に探索して*置き換える。
fooInt(10)
```){Intensional type analysisのイメージ}

+p {
自作言語では現状すべて単相化を行っているので、その際に型を探索してしまえば静的に関数を埋め込めるはずだろうということでより単純な方法を採用しました。このあたりはもう少し実装を進めてメリットデメリットを見極めたいところです…
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+subsection{クラスから単純な構造体へ}<

+p {
C++のクラスはとても複雑です。C++ではクラスのデフォルト・コピー・ムーブ・ユーザー定義コンストラクタのオーバーロードやデストラクタなどがあり、これらを参考して実装するととても複雑になります。また、オブジェクトにはtrivialであったりstandard-layoutになるであったりのいろいろな区分があり、このあたりのオーバロード加減で性質が変わります。memcopyできたりなど。
}

+p {
そういったものは明示的に行いましょうということでクラスといった役割を持たせることはやめました。純粋な構造体としてデータだけを持ちます。
静的なメンバ関数はimplなどで別途実装させます。動的なメンバはtraitとトレイトオブジェクトによるvtableの生成に任せて分離します。これにより
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+section{おわりに}<

+p{
ア！
}

>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>>
